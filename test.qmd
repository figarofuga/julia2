---
title: "Julia練習"
format: html
engine: julia
---

# 使用package

使用するPackageは基本は`TidierData`です。必要な時にやむを得ず、`DataFrames`や`DataFramesMeta`も使います。


```{julia}
using Tidier, DataFrames, DataFramesMeta, Chain
```

# Basic data preparation
## read data

read_csvを使います。missingstringで何をNAとして読むか決めます。

```{julia}

dat = read_csv("rawdata/penguins_raw.csv", missingstring = ["NA"])
dat_prep = @chain dat begin
    @clean_names
    TidierData.@rename(
        culmen_length = `culmen_length_(mm)`, 
        culmen_depth = `culmen_depth_(mm)`, 
        flipper_length = `flipper_length_(mm)`, 
        body_mass = `body_mass_(g)`
    )
    TidierData.@select(-region)
    TidierData.@select(-comments)
end
```


## Dataの確認

基本の他に、DataFrameの構造を見るために以下の方法があります。また、列名を全部出すために以下の方法もあります。
VSCODEを使っている場合は、Viewerがあるのでそれだけでも良いです。
```{julia}
# 最初に構造をみる
first(dat, 5)
@glimpse(dat)

# 全DataFrameをみるため
# show(stdout, "text/plain", dat)
# how(dat, allcols=true)

# 列名の検索
show(stdout, "text/plain", names(dat))

```


## Filtering

条件にそって行を選択する方法です。
```{julia}
# 通常の方法
@filter(dat_prep, sample_number >= 50)
dat_prep |> (x -> @filter(x, sample_number >= 50))
@filter(dat_prep, (sample_number >= 30) & (body_mass >=3500))

# 文字列
@filter(dat_prep, sex == "MALE")
@filter(dat_prep, species in ("Adelie Penguin (Pygoscelis adeliae)","Gentoo penguin (Pygoscelis papua)"))
# 一部の文字列のみ使用
@filter(dat_prep, str_detect(species, "Adelie | Gentoo"))
# negate
@filter(dat_prep, !(sex == "MALE"))

# if_all

DataFrames.subset(dat_prep, 
    [:sample_number, :culmen_length] => 
    ByRow((x, y) -> all(z -> z <100, skipmissing([x, y]))))

# if_any

DataFrames.subset(dat_prep, 
    [:culmen_depth, :culmen_length] => 
    ByRow((x, y) -> any(z -> z <100, skipmissing([x, y]))))

@chain dat_prep begin
  DataFrames.filter(row -> any(<(100), skipmissing([row.sample_number, row.culmen_length])), _)
  DataFrames.filter(row -> all(<(100), skipmissing([row.sample_number, row.culmen_length])), _)
end

```



## Select

条件にそって列を選ぶ方法です。

```{julia}
TidierData.@select(dat_prep, sex, sample_number)

TidierData.@select(dat_prep, starts_with("culmen"))

# 正規表現
TidierData.@select(dat_prep, matches("\\([^()]+\\)"))

# 数値
TidierData.@select(dat_prep, where(is_number))
# 文字列
TidierData.@select(dat_prep, where(is_string))


# 本当はDocumentで見ると、これが出来るはずだがなぜかできない・・・・・・
# TidierData.@select(dat_prep, -(study_name, sample_number))

# 複数除外
@chain dat_prep begin
  DataFramesMeta.@select($(Not(:study_name, :sample_number)))
end

```

## mutate
```{julia}
@chain dat_prep begin
  TidierData.@mutate(
    flipper_in_m = flipper_length / 100) 
  TidierData.@mutate(flipper_add = flipper_in_m + flipper_length)
  TidierData.@mutate(across((culmen_length, culmen_depth), (x -> x/100)))
    end

```

## Group_by

```{julia}
@chain dat_prep begin
  TidierData.@group_by(island, sex) 
  TidierData.@summarise(
    mean_bmi = mean(skipmissing(body_mass)), 
    median_bmi = median(skipmissing(body_mass)), 
    number = n()) 
  TidierData.@ungroup
    end

```

## others

```{julia}
unique(dat_prep[!, :sex])
dat_prep[!, [:island, :species]] |> unique

dat_prep[!, [:island, :species]] |> 
  (x->unique(x))

@glimpse(dat_prep)
describe(dat_prep, :eltype, :nuniqueall, :nmissing,  :min, :mean, :median, :max) |> (x -> show(x, allrows = true))

```

# Basic analysis

## Making description table AKA "Table 1"

```{julia}
using TableOne


descriptive_table = tableone(
           dat_prep,
           :island,
           ["sex", "species", "body_mass", "culmen_length", "culmen_depth", "flipper_length"];
           binvars = ["sex"],
           catvars = ["species"],
           npvars = [ "body_mass", "culmen_length", "culmen_depth", "flipper_length"],
           digits = 2,
           pvalues=true,
           binvardisplay = Dict("sex" => "MALE"),
           varnames = Dict(
               "sex" => "Male, %",
               "species" => "Species, %",
               "body_mass" => "Body Mass Index, kg/m^2",
               "culmen_length" => "Culmen length, m"
           )
       )


```